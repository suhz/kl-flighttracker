// package.json
{
  "name": "aircraft-dashboard",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "db:generate": "prisma generate",
    "db:push": "prisma db push",
    "db:migrate": "prisma migrate dev",
    "collector": "tsx src/collector/index.ts"
  },
  "dependencies": {
    "next": "14.0.0",
    "react": "^18",
    "react-dom": "^18",
    "@prisma/client": "^5.6.0",
    "recharts": "^2.8.0",
    "lucide-react": "^0.294.0",
    "date-fns": "^2.30.0",
    "clsx": "^2.0.0",
    "tailwind-merge": "^2.0.0"
  },
  "devDependencies": {
    "typescript": "^5",
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "autoprefixer": "^10.0.1",
    "postcss": "^8",
    "tailwindcss": "^3.3.0",
    "eslint": "^8",
    "eslint-config-next": "14.0.0",
    "prisma": "^5.6.0",
    "tsx": "^4.6.0"
  }
}

// next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
  output: 'standalone',
  experimental: {
    serverComponentsExternalPackages: ['@prisma/client']
  },
  compress: true,
  poweredByHeader: false,
  webpack: (config) => {
    config.externals = [...config.externals, 'canvas', 'jsdom'];
    return config;
  }
}

module.exports = nextConfig

// tailwind.config.js
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}

// postcss.config.js
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

// .env.example
DATABASE_URL="file:./data/aircraft.db"
ULTRAFEEDER_HOST="http://192.168.1.50:8080"
POLL_INTERVAL="30000"
DATA_RETENTION_DAYS="30"
NODE_ENV="production"
PORT="3000"

// docker-compose.yml
version: '3.8'
services:
  dashboard:
    build: .
    ports:
      - "3000:3000"
    volumes:
      - ./data:/app/data
    environment:
      - DATABASE_URL=file:./data/aircraft.db
      - ULTRAFEEDER_HOST=http://192.168.1.50:8080
      - POLL_INTERVAL=30000
      - DATA_RETENTION_DAYS=30
      - NODE_ENV=production
    restart: unless-stopped

volumes:
  data:
    driver: local

// Dockerfile
FROM node:18-alpine AS dependencies
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npx prisma generate
RUN npm run build

FROM node:18-alpine AS runner
WORKDIR /app
RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs
COPY --from=builder /app/next.config.js ./
COPY --from=builder /app/public ./public
COPY --from=builder /app/.next/standalone ./
COPY --from=builder /app/.next/static ./.next/static
COPY --from=builder /app/prisma ./prisma
COPY --from=builder /app/node_modules/.prisma ./node_modules/.prisma
USER nextjs
EXPOSE 3000
ENV PORT 3000
ENV NODE_ENV production
CMD ["node", "server.js"]

// .dockerignore
node_modules/
.next/
.git/
*.md
.env.local
.env
data/
logs/

// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model AircraftSighting {
  id           Int      @id @default(autoincrement())
  hex          String   // Aircraft ICAO identifier
  flight       String?  // Flight number/callsign
  registration String?  // Aircraft registration
  aircraftType String?  // Aircraft type (A320, B737, etc.)
  airline      String?  // Extracted from flight prefix
  country      String?  // From registration prefix
  countryCode  String?  // Country code (MY, SG, etc.)
  altitude     Int?     // Altitude in feet
  groundSpeed  Float?   // Ground speed
  distance     Float?   // Distance from receiver (km)
  rssi         Float?   // Signal strength
  lat          Float?   // Latitude
  lon          Float?   // Longitude
  squawk       String?  // Transponder code
  seenAt       DateTime // When aircraft was seen
  createdAt    DateTime @default(now())
  
  @@index([seenAt])
  @@index([hex])
  @@index([flight])
  @@index([aircraftType])
  @@index([country])
  @@index([airline])
}

model StatsSnapshot {
  id                 Int      @id @default(autoincrement())
  aircraftWithPos    Int
  aircraftWithoutPos Int
  messagesTotal      Int
  maxDistance        Float?
  snapshotAt         DateTime
  createdAt          DateTime @default(now())
  
  @@index([snapshotAt])
}

// src/lib/db.ts
import { PrismaClient } from '@prisma/client'

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined
}

export const prisma = globalForPrisma.prisma ?? new PrismaClient()

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma

// src/types/aircraft.ts
export interface Aircraft {
  hex: string;
  type: string;
  flight?: string;
  r?: string; // registration
  t?: string; // aircraft type
  desc?: string;
  alt_baro?: number;
  alt_geom?: number;
  gs?: number;
  track?: number;
  lat?: number;
  lon?: number;
  r_dst?: number; // distance from receiver
  squawk?: string;
  category?: string;
  messages?: number;
  seen?: number;
  rssi?: number;
}

export interface UltrafeederAircraft {
  now: number;
  messages: number;
  aircraft: Aircraft[];
}

export interface UltrafeederStats {
  now: number;
  aircraft_with_pos: number;
  aircraft_without_pos: number;
  messages: number;
  total: {
    max_distance: number;
  };
}

export interface DashboardStats {
  totalFlights: number;
  totalAircraft: number;
  aircraftTypes: number;
  countries: number;
  airlines: number;
  maxDistance: number;
}

export interface CountryInfo {
  country: string;
  code: string;
  flag: string;
}

// src/lib/countries.ts
import { CountryInfo } from '@/types/aircraft'

export const REGISTRATION_PREFIXES: Record<string, CountryInfo> = {
  // Malaysia
  '9M': { country: 'Malaysia', code: 'MY', flag: 'üá≤üáæ' },
  
  // Singapore
  '9V': { country: 'Singapore', code: 'SG', flag: 'üá∏üá¨' },
  
  // India
  'VT': { country: 'India', code: 'IN', flag: 'üáÆüá≥' },
  
  // Thailand
  'HS': { country: 'Thailand', code: 'TH', flag: 'üáπüá≠' },
  
  // Indonesia
  'PK': { country: 'Indonesia', code: 'ID', flag: 'üáÆüá©' },
  
  // China
  'B': { country: 'China', code: 'CN', flag: 'üá®üá≥' },
  
  // USA
  'N': { country: 'United States', code: 'US', flag: 'üá∫üá∏' },
  
  // Switzerland
  'HB': { country: 'Switzerland', code: 'CH', flag: 'üá®üá≠' },
  
  // United Kingdom
  'G': { country: 'United Kingdom', code: 'GB', flag: 'üá¨üáß' },
  
  // Germany
  'D': { country: 'Germany', code: 'DE', flag: 'üá©üá™' },
  
  // France
  'F': { country: 'France', code: 'FR', flag: 'üá´üá∑' },
  
  // Netherlands
  'PH': { country: 'Netherlands', code: 'NL', flag: 'üá≥üá±' },
  
  // Turkey
  'TC': { country: 'Turkey', code: 'TR', flag: 'üáπüá∑' },
  
  // UAE
  'A6': { country: 'UAE', code: 'AE', flag: 'üá¶üá™' },
  
  // Qatar
  'A7': { country: 'Qatar', code: 'QA', flag: 'üá∂üá¶' },
  
  // Japan
  'JA': { country: 'Japan', code: 'JP', flag: 'üáØüáµ' },
  
  // South Korea
  'HL': { country: 'South Korea', code: 'KR', flag: 'üá∞üá∑' },
  
  // Australia
  'VH': { country: 'Australia', code: 'AU', flag: 'üá¶üá∫' },
  
  // Philippines
  'RP': { country: 'Philippines', code: 'PH', flag: 'üáµüá≠' },
  
  // Vietnam
  'VN': { country: 'Vietnam', code: 'VN', flag: 'üáªüá≥' },
  
  // Bangladesh
  'S2': { country: 'Bangladesh', code: 'BD', flag: 'üáßüá©' },
  
  // Myanmar
  'XY': { country: 'Myanmar', code: 'MM', flag: 'üá≤üá≤' },
  
  // Cambodia
  'XU': { country: 'Cambodia', code: 'KH', flag: 'üá∞üá≠' },
  
  // Laos
  'RDPL': { country: 'Laos', code: 'LA', flag: 'üá±üá¶' },
  
  // Brunei
  'V8': { country: 'Brunei', code: 'BN', flag: 'üáßüá≥' }
}

export function getCountryFromRegistration(registration: string): CountryInfo {
  if (!registration) return { country: 'Unknown', code: 'XX', flag: '‚ùì' };
  
  // Try longest prefixes first (4 chars, then 3, then 2, then 1)
  for (let i = Math.min(registration.length, 4); i >= 1; i--) {
    const prefix = registration.substring(0, i).toUpperCase();
    if (REGISTRATION_PREFIXES[prefix]) {
      return REGISTRATION_PREFIXES[prefix];
    }
  }
  
  return { country: 'Unknown', code: 'XX', flag: '‚ùì' };
}

export function extractAirlineFromFlight(flight: string): string {
  if (!flight) return 'Unknown';
  const match = flight.trim().match(/^([A-Z]{2,3})/);
  return match ? match[1] : 'Unknown';
}

// src/lib/utils.ts
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

export function formatNumber(num: number): string {
  return new Intl.NumberFormat().format(num);
}

export function formatDistance(distance: number): string {
  if (distance < 1) {
    return `${Math.round(distance * 1000)}m`;
  }
  return `${distance.toFixed(1)}km`;
}

// src/collector/index.ts
import { prisma } from '../lib/db'
import { UltrafeederStats, UltrafeederAircraft } from '../types/aircraft'
import { getCountryFromRegistration, extractAirlineFromFlight } from '../lib/countries'

const ULTRAFEEDER_HOST = process.env.ULTRAFEEDER_HOST || 'http://192.168.1.50:8080';
const POLL_INTERVAL = parseInt(process.env.POLL_INTERVAL || '30000'); // 30 seconds
const DATA_RETENTION_DAYS = parseInt(process.env.DATA_RETENTION_DAYS || '30');

class AircraftCollector {
  private isRunning = false;

  async start() {
    console.log('üõ´ Starting aircraft data collector...');
    this.isRunning = true;
    
    // Initial collection
    await this.collectData();
    
    // Set up interval
    const interval = setInterval(async () => {
      if (!this.isRunning) {
        clearInterval(interval);
        return;
      }
      await this.collectData();
    }, POLL_INTERVAL);

    // Cleanup old data every hour
    setInterval(() => this.cleanupOldData(), 60 * 60 * 1000);
  }

  stop() {
    this.isRunning = false;
  }

  private async collectData() {
    try {
      console.log('üì° Collecting aircraft data...');
      
      const [statsResponse, aircraftResponse] = await Promise.all([
        fetch(`${ULTRAFEEDER_HOST}/data/stats.json`),
        fetch(`${ULTRAFEEDER_HOST}/data/aircraft.json`)
      ]);

      if (!statsResponse.ok || !aircraftResponse.ok) {
        throw new Error('Failed to fetch data from ultrafeeder');
      }

      const stats: UltrafeederStats = await statsResponse.json();
      const aircraftData: UltrafeederAircraft = await aircraftResponse.json();

      await this.saveStatsSnapshot(stats);
      await this.saveAircraftSightings(aircraftData);

      console.log(`‚úÖ Saved ${aircraftData.aircraft.length} aircraft sightings`);
    } catch (error) {
      console.error('‚ùå Error collecting data:', error);
    }
  }

  private async saveStatsSnapshot(stats: UltrafeederStats) {
    await prisma.statsSnapshot.create({
      data: {
        aircraftWithPos: stats.aircraft_with_pos,
        aircraftWithoutPos: stats.aircraft_without_pos,
        messagesTotal: stats.messages,
        maxDistance: stats.total?.max_distance || 0,
        snapshotAt: new Date(stats.now * 1000)
      }
    });
  }

  private async saveAircraftSightings(data: UltrafeederAircraft) {
    const sightings = data.aircraft.map(aircraft => {
      const countryInfo = getCountryFromRegistration(aircraft.r || '');
      const airline = extractAirlineFromFlight(aircraft.flight || '');
      
      return {
        hex: aircraft.hex,
        flight: aircraft.flight?.trim() || null,
        registration: aircraft.r || null,
        aircraftType: aircraft.t || null,
        airline: airline !== 'Unknown' ? airline : null,
        country: countryInfo.country !== 'Unknown' ? countryInfo.country : null,
        countryCode: countryInfo.code !== 'XX' ? countryInfo.code : null,
        altitude: aircraft.alt_baro || null,
        groundSpeed: aircraft.gs || null,
        distance: aircraft.r_dst || null,
        rssi: aircraft.rssi || null,
        lat: aircraft.lat || null,
        lon: aircraft.lon || null,
        squawk: aircraft.squawk || null,
        seenAt: new Date(data.now * 1000)
      };
    });

    // Batch insert for better performance
    await prisma.aircraftSighting.createMany({
      data: sightings,
      skipDuplicates: true
    });
  }

  private async cleanupOldData() {
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - DATA_RETENTION_DAYS);

    const deleted = await prisma.aircraftSighting.deleteMany({
      where: {
        seenAt: {
          lt: cutoffDate
        }
      }
    });

    console.log(`üßπ Cleaned up ${deleted.count} old aircraft sightings`);
  }
}

// Start collector if run directly
if (require.main === module) {
  const collector = new AircraftCollector();
  collector.start();

  // Graceful shutdown
  process.on('SIGINT', () => {
    console.log('üõë Shutting down collector...');
    collector.stop();
    process.exit(0);
  });
}

export default AircraftCollector;

// Start collector in Docker
const collector = new AircraftCollector();
collector.start();

// src/app/layout.tsx
import type { Metadata } from 'next'
import { Inter } from 'next/font/google'
import './globals.css'

const inter = Inter({ subsets: ['latin'] })

export const metadata: Metadata = {
  title: 'KL FlightTracker',
  description: 'Real-time aircraft detected by Suhaimi Amir‚Äôs ADS-B receiver in Kuala Lumpur',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  )
}

// src/app/globals.css
@tailwind base;
@tailwind components;
@tailwind utilities;

// src/app/page.tsx
import { Suspense } from 'react'
import { StatsCards } from '@/components/StatsCards'
import { AircraftTypeChart } from '@/components/AircraftTypeChart'
import { CountryChart } from '@/components/CountryChart'
import { AirlineChart } from '@/components/AirlineChart'
import { CurrentAircraft } from '@/components/CurrentAircraft'
import { getDashboardStats, getTopAircraftTypes, getTopCountries, getTopAirlines } from '@/lib/queries'

export default async function HomePage() {
  return (
    <div className="min-h-screen bg-gray-50">
      <div className="max-w-7xl mx-auto px-4 py-6">
        <header className="mb-8">
          <h1 className="text-3xl font-bold text-gray-900 mb-2">Aircraft Dashboard</h1>
          <p className="text-gray-600">Real-time aviation statistics from tar1090</p>
        </header>
        
        <Suspense fallback={<div>Loading statistics...</div>}>
          <StatsCardsWrapper />
        </Suspense>
        
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8">
          <Suspense fallback={<div>Loading aircraft types...</div>}>
            <AircraftTypeChartWrapper />
          </Suspense>
          
          <Suspense fallback={<div>Loading countries...</div>}>
            <CountryChartWrapper />
          </Suspense>
          
          <Suspense fallback={<div>Loading airlines...</div>}>
            <AirlineChartWrapper />
          </Suspense>
        </div>

        <Suspense fallback={<div>Loading current aircraft...</div>}>
          <CurrentAircraftWrapper />
        </Suspense>
      </div>
    </div>
  )
}

async function StatsCardsWrapper() {
  const stats = await getDashboardStats()
  return <StatsCards stats={stats} />
}

async function AircraftTypeChartWrapper() {
  const data = await getTopAircraftTypes(10)
  return <AircraftTypeChart data={data} />
}

async function CountryChartWrapper() {
  const data = await getTopCountries(10)
  return <CountryChart data={data} />
}

async function AirlineChartWrapper() {
  const data = await getTopAirlines(10)
  return <AirlineChart data={data} />
}

async function CurrentAircraftWrapper() {
  return <CurrentAircraft />
}

// src/components/StatsCards.tsx
import { formatNumber } from '@/lib/utils'
import { DashboardStats } from '@/types/aircraft'

interface StatsCardsProps {
  stats: DashboardStats
}

export function StatsCards({ stats }: StatsCardsProps) {
  const cards = [
    {
      value: formatNumber(stats.totalFlights),
      label: 'Total Flights',
      color: 'bg-blue-600',
      icon: '‚úàÔ∏è'
    },
    {
      value: formatNumber(stats.totalAircraft),
      label: 'Total Aircraft',
      color: 'bg-green-600',
      icon: 'üõ©Ô∏è'
    },
    {
      value: formatNumber(stats.aircraftTypes),
      label: 'Aircraft Types',
      color: 'bg-purple-600',
      icon: 'üè∑Ô∏è'
    },
    {
      value: formatNumber(stats.countries),
      label: 'Countries',
      color: 'bg-orange-600',
      icon: 'üåç'
    },
    {
      value: formatNumber(stats.airlines),
      label: 'Airlines',
      color: 'bg-red-600',
      icon: 'üè¢'
    },
    {
      value: `${stats.maxDistance.toFixed(1)}km`,
      label: 'Max Distance',
      color: 'bg-indigo-600',
      icon: 'üì°'
    }
  ]

  return (
    <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-4 mb-8">
      {cards.map((card, index) => (
        <div key={index} className="bg-white rounded-lg shadow-sm border border-gray-200 p-4">
          <div className="flex items-center justify-between mb-2">
            <span className="text-2xl">{card.icon}</span>
            <div className={`${card.color} text-white rounded-full px-2 py-1 text-xs font-bold`}>
              LIVE
            </div>
          </div>
          <div className="text-2xl font-bold text-gray-900 mb-1">{card.value}</div>
          <div className="text-sm text-gray-600 font-medium">{card.label}</div>
        </div>
      ))}
    </div>
  )
}

// src/components/AircraftTypeChart.tsx
'use client'

import { PieChart, Pie, Cell, ResponsiveContainer, Legend, Tooltip } from 'recharts'

interface AircraftTypeData {
  type: string;
  count: number;
  percentage: number;
}

interface AircraftTypeChartProps {
  data: AircraftTypeData[]
}

const COLORS = [
  '#1e40af', '#dc2626', '#059669', '#d97706', '#7c3aed',
  '#db2777', '#0891b2', '#65a30d', '#dc2626', '#374151'
]

export function AircraftTypeChart({ data }: AircraftTypeChartProps) {
  const chartData = data.map(item => ({
    name: item.type,
    value: item.count,
    percentage: item.percentage
  }))

  return (
    <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
      <h2 className="text-xl font-bold text-gray-900 mb-4">
        Top Aircraft Types
      </h2>
      
      <div className="h-64">
        <ResponsiveContainer width="100%" height="100%">
          <PieChart>
            <Pie
              data={chartData}
              cx="50%"
              cy="50%"
              outerRadius={80}
              fill="#8884d8"
              dataKey="value"
              label={({ percentage }) => `${percentage.toFixed(0)}%`}
            >
              {chartData.map((entry, index) => (
                <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
              ))}
            </Pie>
            <Tooltip 
              formatter={(value: number, name: string) => [
                `${value} aircraft`, 
                name
              ]}
            />
            <Legend 
              wrapperStyle={{ fontSize: '12px' }}
              formatter={(value) => {
                const item = data.find(d => d.type === value)
                return `${value} (${item?.count})`
              }}
            />
          </PieChart>
        </ResponsiveContainer>
      </div>
    </div>
  )
}

// src/components/CountryChart.tsx
'use client'

import { PieChart, Pie, Cell, ResponsiveContainer, Legend, Tooltip } from 'recharts'

interface CountryData {
  country: string;
  flag: string;
  count: number;
  percentage: number;
}

interface CountryChartProps {
  data: CountryData[]
}

const COLORS = [
  '#1e40af', '#dc2626', '#059669', '#d97706', '#7c3aed',
  '#db2777', '#0891b2', '#65a30d', '#dc2626', '#374151'
]

export function CountryChart({ data }: CountryChartProps) {
  const chartData = data.map(item => ({
    name: `${item.flag} ${item.country}`,
    value: item.count,
    percentage: item.percentage
  }))

  return (
    <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
      <h2 className="text-xl font-bold text-gray-900 mb-4">
        Top Countries
      </h2>
      
      <div className="h-64">
        <ResponsiveContainer width="100%" height="100%">
          <PieChart>
            <Pie
              data={chartData}
              cx="50%"
              cy="50%"
              outerRadius={80}
              fill="#8884d8"
              dataKey="value"
              label={({ percentage }) => `${percentage.toFixed(0)}%`}
            >
              {chartData.map((entry, index) => (
                <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
              ))}
            </Pie>
            <Tooltip 
              formatter={(value: number, name: string) => [
                `${value} aircraft`, 
                name
              ]}
            />
            <Legend 
              wrapperStyle={{ fontSize: '12px' }}
              formatter={(value) => {
                const item = data.find(d => `${d.flag} ${d.country}` === value)
                return `${value} (${item?.count})`
              }}
            />
          </PieChart>
        </ResponsiveContainer>
      </div>
    </div>
  )
}

// src/components/AirlineChart.tsx
'use client'

import { PieChart, Pie, Cell, ResponsiveContainer, Legend, Tooltip } from 'recharts'

interface AirlineData {
  airline: string;
  count: number;
  percentage: number;
}

interface AirlineChartProps {
  data: AirlineData[]
}

const COLORS = [
  '#1e40af', '#dc2626', '#059669', '#d97706', '#7c3aed',
  '#db2777', '#0891b2', '#65a30d', '#dc2626', '#374151'
]

export function AirlineChart({ data }: AirlineChartProps) {
  const chartData = data.map(item => ({
    name: item.airline,
    value: item.count,
    percentage: item.percentage
  }))

  return (
    <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
      <h2 className="text-xl font-bold text-gray-900 mb-4">
        Top Airlines
      </h2>
      
      <div className="h-64">
        <ResponsiveContainer width="100%" height="100%">
          <PieChart>
            <Pie
              data={chartData}
              cx="50%"
              cy="50%"
              outerRadius={80}
              fill="#8884d8"
              dataKey="value"
              label={({ percentage }) => `${percentage.toFixed(0)}%`}
            >
              {chartData.map((entry, index) => (
                <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
              ))}
            </Pie>
            <Tooltip 
              formatter={(value: number, name: string) => [
                `${value} flights`, 
                name
              ]}
            />
            <Legend 
              wrapperStyle={{ fontSize: '12px' }}
              formatter={(value) => {
                const item = data.find(d => d.airline === value)
                return `${value} (${item?.count})`
              }}
            />
          </PieChart>
        </ResponsiveContainer>
      </div>
    </div>
  )
}

// src/components/CurrentAircraft.tsx
'use client'

import { useState, useEffect } from 'react'
import { formatDistance } from '@/lib/utils'

interface CurrentAircraftData {
  hex: string;
  flight: string;
  registration: string;
  aircraftType: string;
  country: string;
  flag: string;
  altitude: number;
  groundSpeed: number;
  distance: number;
  rssi: number;
  squawk: string;
}

export function CurrentAircraft() {
  const [aircraft, setAircraft] = useState<CurrentAircraftData[]>([])
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    const fetchCurrentAircraft = async () => {
      try {
        const response = await fetch('/api/current-aircraft')
        const data = await response.json()
        setAircraft(data)
      } catch (error) {
        console.error('Error fetching current aircraft:', error)
      } finally {
        setLoading(false)
      }
    }

    fetchCurrentAircraft()
    const interval = setInterval(fetchCurrentAircraft, 30000) // Update every 30 seconds

    return () => clearInterval(interval)
  }, [])

  if (loading) {
    return (
      <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
        <h2 className="text-xl font-bold text-gray-900 mb-4">Current Aircraft</h2>
        <div className="text-center py-8">Loading current aircraft...</div>
      </div>
    )
  }

  return (
    <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
      <div className="flex items-center justify-between mb-4">
        <h2 className="text-xl font-bold text-gray-900">Current Aircraft</h2>
        <div className="text-sm text-gray-500">
          {aircraft.length} aircraft currently tracked
        </div>
      </div>
      
      <div className="overflow-x-auto">
        <table className="min-w-full divide-y divide-gray-200">
          <thead className="bg-gray-50">
            <tr>
              <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Flight
              </th>
              <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Registration
              </th>
              <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Type
              </th>
              <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Country
              </th>
              <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Altitude
              </th>
              <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Speed
              </th>
              <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Distance
              </th>
              <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Signal
              </th>
            </tr>
          </thead>
          <tbody className="bg-white divide-y divide-gray-200">
            {aircraft.map((plane) => (
              <tr key={plane.hex} className="hover:bg-gray-50">
                <td className="px-4 py-3 text-sm font-medium text-gray-900">
                  {plane.flight || 'N/A'}
                </td>
                <td className="px-4 py-3 text-sm text-gray-900">
                  {plane.registration || 'N/A'}
                </td>
                <td className="px-4 py-3 text-sm text-gray-900">
                  {plane.aircraftType || 'N/A'}
                </td>
                <td className="px-4 py-3 text-sm text-gray-900">
                  <span className="inline-flex items-center gap-1">
                    {plane.flag} {plane.country || 'Unknown'}
                  </span>
                </td>
                <td className="px-4 py-3 text-sm text-gray-900">
                  {plane.altitude ? `${plane.altitude.toLocaleString()}ft` : 'N/A'}
                </td>
                <td className="px-4 py-3 text-sm text-gray-900">
                  {plane.groundSpeed ? `${Math.round(plane.groundSpeed)}kts` : 'N/A'}
                </td>
                <td className="px-4 py-3 text-sm text-gray-900">
                  {plane.distance ? formatDistance(plane.distance) : 'N/A'}
                </td>
                <td className="px-4 py-3 text-sm text-gray-900">
                  <span className={`inline-flex px-2 py-1 text-xs font-medium rounded-full ${
                    plane.rssi > -20 ? 'bg-green-100 text-green-800' :
                    plane.rssi > -30 ? 'bg-yellow-100 text-yellow-800' :
                    'bg-red-100 text-red-800'
                  }`}>
                    {plane.rssi ? `${plane.rssi}dBm` : 'N/A'}
                  </span>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
        
        {aircraft.length === 0 && (
          <div className="text-center py-8 text-gray-500">
            No aircraft currently being tracked
          </div>
        )}
      </div>
    </div>
  )
}

// src/lib/queries.ts
import { prisma } from './db'
import { DashboardStats } from '@/types/aircraft'
import { subDays, subHours } from 'date-fns'
import { REGISTRATION_PREFIXES } from './countries'

export async function getDashboardStats(days = 7): Promise<DashboardStats> {
  const cutoffDate = subDays(new Date(), days)
  
  const [
    totalFlights,
    totalAircraft,
    aircraftTypes,
    countries,
    airlines,
    maxDistanceResult
  ] = await Promise.all([
    // Total unique flights
    prisma.aircraftSighting.groupBy({
      by: ['flight'],
      where: {
        seenAt: { gte: cutoffDate },
        flight: { not: null }
      }
    }).then(result => result.length),
    
    // Total unique aircraft registrations
    prisma.aircraftSighting.groupBy({
      by: ['registration'],
      where: {
        seenAt: { gte: cutoffDate },
        registration: { not: null }
      }
    }).then(result => result.length),
    
    // Unique aircraft types
    prisma.aircraftSighting.groupBy({
      by: ['aircraftType'],
      where: {
        seenAt: { gte: cutoffDate },
        aircraftType: { not: null }
      }
    }).then(result => result.length),
    
    // Unique countries
    prisma.aircraftSighting.groupBy({
      by: ['country'],
      where: {
        seenAt: { gte: cutoffDate },
        country: { not: null }
      }
    }).then(result => result.length),
    
    // Unique airlines
    prisma.aircraftSighting.groupBy({
      by: ['airline'],
      where: {
        seenAt: { gte: cutoffDate },
        airline: { not: null }
      }
    }).then(result => result.length),
    
    // Max distance
    prisma.aircraftSighting.aggregate({
      where: {
        seenAt: { gte: cutoffDate },
        distance: { not: null }
      },
      _max: {
        distance: true
      }
    })
  ])
  
  return {
    totalFlights,
    totalAircraft,
    aircraftTypes,
    countries,
    airlines,
    maxDistance: maxDistanceResult._max.distance || 0
  }
}

export async function getTopAircraftTypes(limit = 10, days = 7) {
  const cutoffDate = subDays(new Date(), days)
  
  const results = await prisma.aircraftSighting.groupBy({
    by: ['aircraftType'],
    where: {
      seenAt: { gte: cutoffDate },
      aircraftType: { not: null }
    },
    _count: {
      aircraftType: true
    },
    orderBy: {
      _count: {
        aircraftType: 'desc'
      }
    },
    take: limit
  })
  
  const total = results.reduce((sum, item) => sum + item._count.aircraftType, 0)
  
  return results.map(item => ({
    type: item.aircraftType!,
    count: item._count.aircraftType,
    percentage: (item._count.aircraftType / total) * 100
  }))
}

export async function getTopCountries(limit = 10, days = 7) {
  const cutoffDate = subDays(new Date(), days)
  
  const results = await prisma.aircraftSighting.groupBy({
    by: ['country', 'countryCode'],
    where: {
      seenAt: { gte: cutoffDate },
      country: { not: null }
    },
    _count: {
      country: true
    },
    orderBy: {
      _count: {
        country: 'desc'
      }
    },
    take: limit
  })
  
  const total = results.reduce((sum, item) => sum + item._count.country, 0)
  
  return results.map(item => {
    // Find flag from registration prefixes
    const countryInfo = Object.values(REGISTRATION_PREFIXES).find(
      info => info.country === item.country
    )
    
    return {
      country: item.country!,
      flag: countryInfo?.flag || 'üè≥Ô∏è',
      count: item._count.country,
      percentage: (item._count.country / total) * 100
    }
  })
}

export async function getTopAirlines(limit = 10, days = 7) {
  const cutoffDate = subDays(new Date(), days)
  
  const results = await prisma.aircraftSighting.groupBy({
    by: ['airline'],
    where: {
      seenAt: { gte: cutoffDate },
      airline: { not: null }
    },
    _count: {
      airline: true
    },
    orderBy: {
      _count: {
        airline: 'desc'
      }
    },
    take: limit
  })
  
  const total = results.reduce((sum, item) => sum + item._count.airline, 0)
  
  return results.map(item => ({
    airline: item.airline!,
    count: item._count.airline,
    percentage: (item._count.airline / total) * 100
  }))
}

export async function getCurrentAircraft() {
  const recentTime = subHours(new Date(), 1) // Aircraft seen in last hour
  
  const aircraft = await prisma.aircraftSighting.findMany({
    where: {
      seenAt: { gte: recentTime }
    },
    orderBy: {
      seenAt: 'desc'
    },
    take: 50,
    distinct: ['hex'] // Get unique aircraft only
  })
  
  return aircraft.map(plane => {
    // Find flag from registration prefixes
    const countryInfo = Object.values(REGISTRATION_PREFIXES).find(
      info => info.country === plane.country
    )
    
    return {
      hex: plane.hex,
      flight: plane.flight || '',
      registration: plane.registration || '',
      aircraftType: plane.aircraftType || '',
      country: plane.country || 'Unknown',
      flag: countryInfo?.flag || '‚ùì',
      altitude: plane.altitude || 0,
      groundSpeed: plane.groundSpeed || 0,
      distance: plane.distance || 0,
      rssi: plane.rssi || 0,
      squawk: plane.squawk || ''
    }
  })
}

// src/app/api/health/route.ts
import { NextResponse } from 'next/server'
import { prisma } from '@/lib/db'

export async function GET() {
  try {
    await prisma.$queryRaw`SELECT 1`
    
    const recentData = await prisma.aircraftSighting.count({
      where: {
        seenAt: { gte: new Date(Date.now() - 5 * 60 * 1000) } // Last 5 minutes
      }
    })
    
    const status = {
      status: 'healthy',
      database: 'connected',
      recentAircraft: recentData,
      timestamp: new Date().toISOString()
    }
    
    return NextResponse.json(status)
  } catch (error) {
    return NextResponse.json(
      { 
        status: 'error', 
        error: error instanceof Error ? error.message : 'Unknown error' 
      }, 
      { status: 500 }
    )
  }
}

// src/app/api/stats/route.ts
import { NextResponse } from 'next/server'
import { getDashboardStats } from '@/lib/queries'

export async function GET() {
  try {
    const stats = await getDashboardStats()
    return NextResponse.json(stats)
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to fetch statistics' },
      { status: 500 }
    )
  }
}

// src/app/api/aircraft-types/route.ts
import { NextResponse } from 'next/server'
import { getTopAircraftTypes } from '@/lib/queries'

export async function GET() {
  try {
    const data = await getTopAircraftTypes(10)
    return NextResponse.json(data)
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to fetch aircraft types' },
      { status: 500 }
    )
  }
}

// src/app/api/countries/route.ts
import { NextResponse } from 'next/server'
import { getTopCountries } from '@/lib/queries'

export async function GET() {
  try {
    const data = await getTopCountries(10)
    return NextResponse.json(data)
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to fetch countries' },
      { status: 500 }
    )
  }
}

// src/app/api/airlines/route.ts
import { NextResponse } from 'next/server'
import { getTopAirlines } from '@/lib/queries'

export async function GET() {
  try {
    const data = await getTopAirlines(10)
    return NextResponse.json(data)
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to fetch airlines' },
      { status: 500 }
    )
  }
}

// src/app/api/current-aircraft/route.ts
import { NextResponse } from 'next/server'
import { getCurrentAircraft } from '@/lib/queries'

export async function GET() {
  try {
    const data = await getCurrentAircraft()
    return NextResponse.json(data)
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to fetch current aircraft' },
      { status: 500 }
    )
  }
}

// README.md
# Aircraft Dashboard

A simple, Docker-based aircraft tracking dashboard that integrates with tar1090/Ultrafeeder to display real-time aviation statistics.

## Features

- üìä **6 Key Statistics Cards** - Total flights, aircraft, types, countries, airlines, max distance
- üìà **3 Interactive Charts** - Top aircraft types, countries, and airlines (pie charts)
- ‚úàÔ∏è **Current Aircraft Table** - Live aircraft currently being tracked
- üåç **Country Detection** - Automatic country identification from aircraft registration prefixes
- üöÄ **Docker Deployment** - Single container, easy to run anywhere
- üì° **Real-time Updates** - Automatically polls tar1090 every 30 seconds

## Quick Start

1. **Clone and setup:**
```bash
git clone <repository> aircraft-dashboard
cd aircraft-dashboard
mkdir -p data
```

2. **Configure environment:**
```bash
cp .env.example .env
# Edit .env and set your ULTRAFEEDER_HOST
nano .env
```

3. **Start with Docker:**
```bash
docker-compose up -d
```

4. **Access dashboard:**
```
http://localhost:3000
```

## Configuration

Edit `.env` file:
```env
ULTRAFEEDER_HOST="http://192.168.1.50:8080"  # Your tar1090 host
POLL_INTERVAL="30000"                        # Data collection interval (30 seconds)
DATA_RETENTION_DAYS="30"                     # How long to keep data
```

## Data Sources

The dashboard uses only tar1090's basic JSON endpoints:
- `GET /data/aircraft.json` - Current aircraft data
- `GET /data/stats.json` - System statistics

## Country Detection

Countries are automatically detected from aircraft registration prefixes:
- **9M-xxx** ‚Üí Malaysia üá≤üáæ
- **9V-xxx** ‚Üí Singapore üá∏üá¨  
- **VT-xxx** ‚Üí India üáÆüá≥
- **N-xxx** ‚Üí United States üá∫üá∏
- And many more...

## Monitoring

Check system health:
```bash
# Container status
docker-compose ps

# View logs
docker-compose logs -f

# Health check
curl http://localhost:3000/api/health
```

## Development

Run locally:
```bash
npm install
npx prisma generate
npx prisma db push
npm run dev
```

## License

MIT License - feel free to use and modify!